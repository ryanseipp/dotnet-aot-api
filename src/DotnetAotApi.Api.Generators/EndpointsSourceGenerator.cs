using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DotnetAotApi.Api.Generators;

[Generator(LanguageNames.CSharp)]
public class EndpointsSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var endpointClasses = context
            .SyntaxProvider
            .CreateSyntaxProvider(Predicate, Transform)
            .Where(m => m is not null);

        context.RegisterSourceOutput(
            endpointClasses.Collect(),
            static (ctx, classNames) =>
            {
                var implementedMemberInvocations = string.Join(
                    "\n        ",
                    classNames.Select(cn => $"{cn}.MapEndpoints(builder);")
                );

                ctx.AddSource(
                    "MapEndpointsExtensions.g.cs",
                    $$"""
                    // <auto-generated/>
                    namespace DotnetAotApi.Api.Features;

                    public static partial class MapEndpointsExtensions
                    {
                        static partial void MapEndpoints(IEndpointRouteBuilder builder)
                        {
                            {{implementedMemberInvocations}}
                        }
                    }
                    """
                );
            }
        );
    }

    private static bool Predicate(SyntaxNode n, CancellationToken ct) =>
        n is TypeDeclarationSyntax typeSyntax
        && (typeSyntax.BaseList?.Types.Any(bt => bt.ToString() == "IEndpoint") ?? false);

    private static string Transform(GeneratorSyntaxContext ctx, CancellationToken ct) =>
        (ctx.SemanticModel.GetDeclaredSymbol(ctx.Node) as INamedTypeSymbol)?.ToDisplayString();
}
